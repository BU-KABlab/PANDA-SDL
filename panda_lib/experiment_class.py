""" Experiment data class"""

# pylint: disable=invalid-name, line-too-long, import-outside-toplevel, broad-exception-caught, protected-access
import json
import os
from dataclasses import field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from pathlib import Path
from typing import List, Optional, Tuple, Union, get_type_hints

from pydantic import ConfigDict, RootModel
from pydantic.dataclasses import dataclass

from panda_lib.sql_tools.sql_utilities import (execute_sql_command,
                                                execute_sql_command_no_return)


class ExperimentResultsRecord:
    """
    A class for representing a single entry in a result table.
    The table has columns:
    id,
    experiment_id,
    result_type,
    result_value
    """

    def __init__(
        self, experiment_id: int, result_type: str, result_value: str, context=None
    ):
        self.experiment_id = experiment_id
        self.result_type = result_type
        self.result_value = result_value
        self.context = context

    def __str__(self):
        return f"Experiment ID: {self.experiment_id}, Result Type: {self.result_type}, Result Value: {self.result_value}, Context: {self.context}"

    def __repr__(self):
        return f"ResultTableRecord({self.experiment_id}, {self.result_type}, {self.result_value}, {self.context})"

    def __eq__(self, other):
        return (
            self.experiment_id == other.experiment_id
            and self.result_type == other.result_type
            and self.result_value == other.result_value
            and self.context == other.context
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(
            (self.experiment_id, self.result_type, self.result_value, self.context)
        )

    def __iter__(self):
        yield self.experiment_id
        yield self.result_type
        yield self.result_value
        yield self.context

    def __list__(self):
        return [self.experiment_id, self.result_type, self.result_value, self.context]


class ExperimentParameterRecord:
    """
    A class for representing a single entry in an experiment parameter table.
    The table has columns:
    id,
    experiment_id,
    parameter_type,
    parameter_value
    """

    def __init__(self, experiment_id: int, parameter_type: str, parameter_value: str):
        self.experiment_id = experiment_id
        self.parameter_type = parameter_type
        self.parameter_value = parameter_value

    def __str__(self):
        return f"Experiment ID: {self.experiment_id}, Parameter Type: {self.parameter_type}, Parameter Value: {self.parameter_value}"

    def __repr__(self):
        return f"ExperimentParameterRecord({self.experiment_id}, {self.parameter_type}, {self.parameter_value})"

    def __eq__(self, other):
        return (
            self.experiment_id == other.experiment_id
            and self.parameter_type == other.parameter_type
            and self.parameter_value == other.parameter_value
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash((self.experiment_id, self.parameter_type, self.parameter_value))

    def __iter__(self):
        yield self.experiment_id
        yield self.parameter_type
        yield self.parameter_value

    def __list__(self):
        return [self.experiment_id, self.parameter_type, self.parameter_value]


class ExperimentStatus(str, Enum):
    """Define the possible statuses of an experiment"""

    NEW = "new"
    QUEUED = "queued"
    RUNNING = "running"
    OCPCHECK = "ocpcheck"
    DEPOSITING = "depositing"
    EDEPOSITING = "e_depositing"
    RINSING = "rinsing"
    ERINSING = "rinsing electrode"
    BASELINE = "baselining"
    CHARACTERIZING = "characterizing"
    CA = "cyclic-amperometry"
    CV = "cyclic-voltametry"
    FINAL_RINSE = "final_rinse"
    COMPLETE = "complete"
    ERROR = "error"
    MIXING = "mixing"
    IMAGING = "imaging"
    CLEARING = "clearing"
    FLUSHING = "flushing"
    PAUSED = "paused"
    CANCELLED = "cancelled"
    PENDING = "pending"  # pending experiments either are waiting for a well to be assigned or lack the correct well type
    SAVING = "saving"
    ANALYZING = "analyzing"


@dataclass(config=ConfigDict(validate_assignment=True))
class ExperimentResult:
    """Define the data that is generated by an experiment"""

    experiment_id: int = None
    well_id: str = None
    ocp_ca_file: List[Tuple[Path, str]] = field(default_factory=list)
    ocp_ca_passed: List[Tuple[bool, str]] = field(default_factory=list)
    ocp_cv_file: List[Tuple[Path, str]] = field(default_factory=list)
    ocp_cv_passed: List[Tuple[bool, str]] = field(default_factory=list)
    ocp_cv_final_voltage: List[Tuple[Decimal, str]] = field(default_factory=list)
    ca_data_file: List[Tuple[Path, str]] = field(default_factory=list)
    cv_data_file: List[Tuple[Path, str]] = field(default_factory=list)
    image: List[Tuple[Path, str]] = field(default_factory=list)
    # deposition_plot_files: list[Path] = field(default_factory=list)
    # deposition_max_values: list[Decimal] = field(default_factory=list)
    # depsotion_min_values: list[Decimal] = field(default_factory=list)
    # characterization_plot_files: list[Path] = field(default_factory=list)
    # characterization_max_values: list[Decimal] = field(default_factory=list)
    # characterization_min_values: list[Decimal] = field(default_factory=list)
    pumping_record: list = None

    def set_ocp_ca_file(
        self, file: Path, passed: bool, final_voltage: Decimal, context: str = None
    ):
        """Set the file, the pass/fail status, and the final voltage"""
        self.ocp_ca_file.append((file, context))
        self.ocp_ca_passed.append((passed, context))
        self.ocp_cv_final_voltage.append((final_voltage, context))

    def set_ocp_cv_file(
        self, file: Path, passed: bool, final_voltage: Decimal, context: str = None
    ):
        """Set the file, the pass/fail status, and the final voltage"""
        self.ocp_cv_file.append((file, context))
        self.ocp_cv_passed.append((passed, context))
        self.ocp_cv_final_voltage.append((final_voltage, context))

    def set_ca_data_file(
        self,
        file: Path,
        # plot_file: Path = None,
        # max_value: Decimal = None,
        # min_value: Decimal = None,
        context: str = None,
    ):
        """Set the file, the plot file, the max value, and the min value"""
        self.ca_data_file.append((file, context))
        # if plot_file is not None:
        #     self.deposition_plot_files.append(plot_file)
        # if max_value is not None:
        #     self.deposition_max_values.append(max_value)
        # if min_value is not None:
        #     self.depsotion_min_values.append(min_value)

    def set_cv_data_file(
        self,
        file: Path,
        # plot_file: Path = None,
        # max_value: Decimal = None,
        # min_value: Decimal = None,
        context: str = None,
    ):
        """Set the file, the plot file, the max value, and the min value"""
        self.cv_data_file.append((file, context))
        # if plot_file is not None:
        #     self.characterization_plot_files.append(plot_file)
        # if max_value is not None:
        #     self.characterization_max_values.append(max_value)
        # if min_value is not None:
        #     self.characterization_min_values.append(min_value)

    def set_pumping_record(self, record: list):
        """Set the pumping record"""
        self.pumping_record = record

    def append_image_file(self, file: Path, context: str = None):
        """Append the image file"""
        self.image.append((file, context))

    def one_to_many(self) -> list[ExperimentResultsRecord]:
        """Turn the results object into individual result table records"""
        all_results = []
        for key, value in self.__dict__.items():
            if key in ["experiment_id", "well_id", "pumping_record"]:
                continue
            if isinstance(value, list):
                for _, item in enumerate(value):
                    all_results.append(
                        ExperimentResultsRecord(
                            self.experiment_id, key, item[0], item[1]
                        )
                    )
            else:
                all_results.append(
                    ExperimentResultsRecord(self.experiment_id, key, value)
                )
        return all_results

    def to_results_records(self) -> list[ExperimentResultsRecord]:
        """Turn the results object into individual result table records"""
        all_results = []
        for key, value in self.__dict__.items():
            if key in ["experiment_id", "well_id", "pumping_record"]:
                continue
            if isinstance(value, list):
                for _, item in enumerate(value):
                    all_results.append(
                        ExperimentResultsRecord(
                            self.experiment_id, key, item[0], item[1]
                        )
                    )
            else:
                all_results.append(
                    ExperimentResultsRecord(self.experiment_id, key, value)
                )
        return all_results


@dataclass(config=ConfigDict(validate_assignment=True, arbitrary_types_allowed=True))
class ExperimentBase:
    """Define the common data used to run and define an experiment"""

    experiment_id: int = None
    experiment_name: str = None
    protocol_id: Union[int,str] = None
    priority: Optional[int] = 0
    well_id: Optional[str] = None
    pin: Union[str, int] = None
    project_id: int = None
    solutions: dict = None
    solutions_corrected: dict = solutions
    well_type_number: int = (
        None  # is used to indicate the type of well the experiment should run in
    )
    pumping_rate: Decimal = Decimal("0.3")
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None  # Optional[FilePath] = None
    well_id: Optional[str] = None
    pin: str = None
    project_id: int = None
    solutions: dict = None
    solutions_corrected: dict = solutions
    well_type_number: int = (
        None  # is used to indicate the type of well the experiment should run in
    )
    pumping_rate: Decimal = Decimal(0.3)
    status: ExperimentStatus = ExperimentStatus.NEW
    status_date: datetime = field(default_factory=datetime.now)
    filename: str = None  # Optional[FilePath] = None
    results: Optional[ExperimentResult] = None
    project_campaign_id: int = None
    protocol_type: int = 1  # depreciated
    plate_id: Optional[int] = None
    override_well_selection: int = 0  # 0 is normal, 1 is override
    process_type: Optional[int] = 1
    jira_issue_key: Optional[str] = None
    experiment_type: int = 0
    well: object= None
    # FIXME: Seperate the set status, and set status and save methods from the experimentbase. The experiment base should just be a dataclass
    # What could be an alternative is that there is a wrapper class that has the set status and set status and save methods using what
    # Method that the project chooses to use to save the data to the database
    def set_status(self, new_status: ExperimentStatus) -> None:
        """Set the status of the experiment"""
        self.status = new_status
        self.status_date = datetime.now().isoformat(timespec="seconds")
        try:
            if os.environ["PANDA_SDL_TESTING"] == '1' or os.environ["PANDA_SDL_USE_OBS"] == '0':
                from .obs_controls import MockOBSController as OBSController
            else:
                from .obs_controls import OBSController


            OBSController().place_experiment_on_screen(self)
        except Exception as e:
            print(f"Error sending status to OBS: {e}")
            # don't raise the error, just print it

    def set_status_and_save(self, new_status: ExperimentStatus) -> None:
        """Set the status and status date of the experiment"""
        from .sql_tools import sql_wellplate

        self.status = new_status
        self.status_date = datetime.now().isoformat(timespec="seconds")
        self.well.status = new_status
        self.well.status_date = datetime.now().isoformat(timespec="seconds")
        # Save the well to the database
        if self.well:
            sql_wellplate.save_well_to_db(self.well)

        else:
            print("Well object not set. Saving to db via alternative method")
            update_experiment_status(self)

        # Save the experiment to the database
        update_experiment(self)
        try:
            if os.environ["PANDA_SDL_TESTING"] == '1' or os.environ["PANDA_SDL_USE_OBS"] == '0':
                from .obs_controls import MockOBSController as OBSController
            else:
                from .obs_controls import OBSController

            OBSController().place_experiment_on_screen(self)
        except Exception as e:
            print(f"Error sending status to OBS: {e}")
            # don't raise the error, just print it

    def is_same_id(self, other) -> bool:
        """Check if two experiments have the same id"""

        return self.experiment_id == other.id

    def is_same_well_id(self, other) -> bool:
        """Check if two experiments have the same well id"""

        return self.well_id == other.well_id

    ## other check if same methods

    def generate_parameter_list(self) -> list[ExperimentParameterRecord]:
        """Turn the experiment object into a list of individual experiment parameter table records"""
        all_parameters = [
            ExperimentParameterRecord(
                self.experiment_id, parameter_type, parameter_value
            )
            for parameter_type, parameter_value in self.__dict__.items()
        ]

        # Remove project_id, project_campaign_id, well_type,protocol_id, pin, experiment_type, jira_issue_key, priority, process_type, filename, status, status_date, results, well
        all_parameters = [
            parameter
            for parameter in all_parameters
            if parameter.parameter_type
            not in [
                "project_id",
                "project_campaign_id",
                "well_type",
                "protocol_id",
                "protocol_type",  # depreciated
                "pin",
                "experiment_type",
                "jira_issue_key",
                "priority",
                "process_type",
                "filename",
                "status",
                "status_date",
                "results",
                "well",
                "well_id",
                "experiment_id",
            ]
        ]

        return all_parameters

    # def generate_result_list(self) -> list[ExperimentResultsRecord]:

    def map_parameter_list_to_experiment(
        self, parameter_list: list[ExperimentParameterRecord]
    ):
        """Map the parameter list to the experiment object"""

        def find_attribute_in_hierarchy(cls, attr):
            """Recursively search for an attribute in a class and its subclasses"""
            if hasattr(cls, attr):
                return cls
            for subclass in cls.__subclasses__():
                result = find_attribute_in_hierarchy(subclass, attr)
                if result is not None:
                    return result
            return None

        for parameter in parameter_list:
            parameter = ExperimentParameterRecord(*parameter)
            try:
                attribute_type = get_all_type_hints(type(self))[
                    parameter.parameter_type
                ]
            except KeyError as exc:
                # The attribute is not in ExperimentBase, check in the class hierarchy
                cls = find_attribute_in_hierarchy(
                    self.__class__, parameter.parameter_type
                )
                if cls is not None:
                    attribute_type = get_all_type_hints(cls)[parameter.parameter_type]
                else:
                    print(
                        f"Attribute {parameter.parameter_type} not found in class hierarchy"
                    )
                    raise AttributeError(
                        f"Attribute {parameter.parameter_type} not found in class hierarchy"
                    ) from exc

            if isinstance(
                attribute_type, type(Union)
            ):  # Check if the type hint is a Union
                # The attribute can be one of several types
                possible_types = attribute_type.__args__
                for possible_type in possible_types:
                    # Try to convert the parameter value to each possible type
                    try:
                        parameter.parameter_value = possible_type(
                            parameter.parameter_value
                        )
                        break  # If the conversion succeeds, stop trying other types
                    except ValueError:
                        pass  # If the conversion fails, try the next type
            elif (
                hasattr(attribute_type, "_name") and attribute_type._name == "Optional"
            ):  # Check if the type hint is Optional
                # The attribute can be None or the specified type
                possible_type = attribute_type.__args__[0]
                if parameter.parameter_value is None:
                    parameter.parameter_value = None
                else:
                    # Try to convert the parameter value to the specified type
                    parameter.parameter_value = possible_type(parameter.parameter_value)

            elif attribute_type == int:
                parameter.parameter_value = int(parameter.parameter_value)
            elif attribute_type in [Decimal, float]:
                parameter.parameter_value = Decimal(parameter.parameter_value)
            elif attribute_type == bool:
                parameter.parameter_value = bool(parameter.parameter_value)
            elif attribute_type == str:
                parameter.parameter_value = str(parameter.parameter_value)
            elif attribute_type == dict and json.loads(parameter.parameter_value):
                parameter.parameter_value = json.loads(parameter.parameter_value)
            elif attribute_type == ExperimentStatus:
                parameter.parameter_value = ExperimentStatus(parameter.parameter_value)
            elif attribute_type == datetime:
                parameter.parameter_value = datetime.fromisoformat(
                    parameter.parameter_value
                )
            else:
                print(f"Unknown attribute type {attribute_type}")

            if hasattr(self, parameter.parameter_type):  # Check if the attribute exists
                setattr(self, parameter.parameter_type, parameter.parameter_value)
            else:
                # If the attribute does not exist, add it to the object, this is
                # to avoid every experiment needing to have attributes of other experiments
                # Example: Edot experiments have edot_concentration, but not all experiments have this
                setattr(
                    self.__class__, parameter.parameter_type, parameter.parameter_value
                )


@dataclass(config=ConfigDict(validate_assignment=True, arbitrary_types_allowed=True))
class CorrectionFactorExperiment(ExperimentBase):
    """Define the data that is used to run an experiment"""

    project_id: int = 11
    correction_factor: Decimal = Decimal(1.0)


@dataclass(config=ConfigDict(validate_assignment=True, arbitrary_types_allowed=True))
class EchemExperimentBase(ExperimentBase):
    """
    Define the data that is used to run an experiment

    This is the base class for all echem experiments
    """

    experiment_type: int = 1  # echem generic
    ocp: int = 1  # Open Circuit Potential
    ca: int = 1  # Cyclic Amperometry
    cv: int = 1  # Cyclic Voltammetry
    baseline: int = 0  # Baseline

    flush_sol_name: str = ""  # Flush solution name
    flush_vol: int = 0  # Flush solution volume

    mix = 0  # Binary mix or dont mix
    mix_count: int = 0  # Number of times to mix
    mix_volume: int = 0  # Volume to mix
    rinse_count: int = 4  # Default rinse count
    rinse_vol: int = 120  # Default rinse volume

    ca_sample_period: Decimal = Decimal(0.1)  # Deposition sample period
    ca_prestep_voltage: Decimal = Decimal(0.0)  # Pre-step voltage (V)
    ca_prestep_time_delay: Decimal = Decimal(0.0)  # Pre-step delay time (s)
    ca_step_1_voltage: Decimal = Decimal(-1.7)  # Step 1 voltage (V), deposition potential (V)
    ca_step_1_time: Decimal = Decimal(300.0)  # run time 300 seconds, deposition duration (s)
    ca_step_2_voltage: Decimal = Decimal(0.0)  # Step 2 voltage (V)
    ca_step_2_time: Decimal = Decimal(0.0)  # Step 2 time (s)
    ca_sample_rate: Decimal = Decimal(0.5)  # sample period (s)

    char_sol_name: str = ""  # Characterization solution name
    char_vol: int = 0  # Characterization solution volume
    cv_sample_period: Decimal = Decimal(0.1)  # Characterization sample period
    cv_initial_voltage: Decimal = Decimal(0.0)  # initial voltage
    cv_first_anodic_peak: Decimal = Decimal(0.5)  # first anodic peak
    cv_second_anodic_peak: Decimal = Decimal(-0.2)  # second anodic peak
    cv_final_voltage: Decimal = Decimal(0.0)  # final voltage
    cv_step_size: Decimal = Decimal(0.01)  # step size
    cv_cycle_count: int = 3  # number of cycles
    cv_scan_rate_cycle_1: Decimal = Decimal(0.1)
    cv_scan_rate_cycle_2: Decimal = Decimal(0.1)
    cv_scan_rate_cycle_3: Decimal = Decimal(0.1)

    @property
    def cv_sample_rate(self):
        """CVstep / CVsr1"""
        return round(self.cv_step_size / self.cv_scan_rate_cycle_1, 4)

    def print_ca_parameters(self) -> str:
        """Print the CA parameters"""
        if self.ca:
            return f"""
        CA Parameters
            Pre-step Voltage: {self.ca_prestep_voltage}
            Pre-step Time Delay: {self.ca_prestep_time_delay}
            Step 1 Voltage: {self.ca_step_1_voltage}
            Step 1 Time: {self.ca_step_1_time}
            Step 2 Voltage: {self.ca_step_2_voltage}
            Step 2 Time: {self.ca_step_2_time}
            CA Sample Rate: {self.ca_sample_rate}
    """
        else:
            return """
        CA Not selected
    """

    def print_cv_parameters(self) -> str:
        """Print the CV parameters"""
        if self.cv:
            return f"""
        CV Parameters
            CV: {bool(self.cv)}
            CV Baseline: {bool(self.baseline)}
            Sample Period: {self.cv_sample_period}
            Initial Voltage (CVvi): {self.cv_initial_voltage}
            First Anodic Peak (CVap1): {self.cv_first_anodic_peak}
            Second Anodic Peak (CVap2): {self.cv_second_anodic_peak}
            Final Voltage (CVvf): {self.cv_final_voltage}
            Step Size (CVstep): {self.cv_step_size}
            Cycle Count: {self.cv_cycle_count}
            Scan Rate Cycle 1 (CVsr1): {self.cv_scan_rate_cycle_1}
            Scan Rate Cycle 2 (CVsr2): {self.cv_scan_rate_cycle_2}
            Scan Rate Cycle 3 (CVsr3): {self.cv_scan_rate_cycle_3}
            CV Sample Rate: {self.cv_sample_rate}
    """
        else:
            return """
        CV not selected
"""

    def print_all_experiment_parameters(self) -> str:
        """Print the experiment parameters"""
        return f"""
{self.experiment_name} 
        Plate #: {self.plate_id}
        Experiment ID: {self.experiment_id}
        Well ID: {self.well_id}
        Status: {self.status.value}
        Priority: {self.priority}
        Solutions: {self.solutions}
        Corrected Solutions: {self.solutions_corrected}
        Filename: {self.filename}

        Echem Parameters
            Run Open Circuit Potential: {bool(self.ocp)}
            Run Cyclic Amperometry: {bool(self.ca)}
            Run Cyclic Voltammetry: {bool(self.cv)}
            Run CV Baseline: {bool(self.baseline)}
            Flush Solution Name: {self.flush_sol_name}
            Flush Solution Volume: {self.flush_vol}
            Mix: {bool(self.mix)}
            Mix Count: {self.mix_count}
            Mix Volume: {self.mix_volume}
            Rinse Count: {self.rinse_count}
            Rinse Volume: {self.rinse_vol}

        {self.print_ca_parameters()}

        {self.print_cv_parameters()}
    """


@dataclass(config=ConfigDict(validate_assignment=True, arbitrary_types_allowed=True))
class EdotExperiment(EchemExperimentBase):
    """Define the default data that is used to run an edot experiment"""

    project_id: int = 16
    well_type_number: int = 4  # ito
    experiment_type: int = 2  # edot
    edot_concentration: Decimal = Decimal(0.1)  # mM

@dataclass(config=ConfigDict(validate_assignment=True, arbitrary_types_allowed=True))
class FeCnVerificaitonExperiments(EchemExperimentBase):
    """Define the default data that is used to run an FeCn experiment"""

    project_id: int = 17
    well_type_number: int = 4  # ito

experiment_types_by_project_id = {
    0: ExperimentBase,
    1: EchemExperimentBase,
    16: EdotExperiment,
    11: CorrectionFactorExperiment,
    17: FeCnVerificaitonExperiments,
    999: EdotExperiment
}


def make_test_base_value() -> ExperimentBase:
    """Create a test experiment value for the class"""
    return ExperimentBase(
        experiment_id=0,
        experiment_name="test",
        priority=2,
        well_id="D5",
        pin=100099000999,
        project_id=3,
        solutions={"dmf": 0, "peg": 145, "acrylate": 145, "ferrocene": 0, "custom": 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().isoformat(timespec="seconds"),
        filename=f"test_{0}.json",
        results=None,
    )


def make_test_value() -> ExperimentBase:
    """Create a test experiment value for the class"""
    return ExperimentBase(
        experiment_id=0,
        experiment_name="test",
        priority=2,
        well_id="D5",
        pin='0',
        project_id=3,
        solutions={"dmf": 0, "peg": 145, "acrylate": 145, "ferrocene": 0, "custom": 0},
        status=ExperimentStatus.QUEUED,
        status_date=datetime.now().isoformat(timespec="seconds"),
        filename=f"test_{0}.json",
        results=None,
    )


def parse_experiment(json_string: str) -> ExperimentBase:
    """Parse an experiment from a json string"""
    if isinstance(json_string, str):
        parsed_json = json.loads(json_string)
        if "ocp" in parsed_json:
            return RootModel[EchemExperimentBase].model_validate_json(json_string).root
    return RootModel[ExperimentBase].model_validate_json(json_string).root


# def serialize_experiment(experiment: (Experiment,ExperimentBase)) -> str:
#     '''Serialize an experiment to a json string'''
#     if isinstance(experiment, Experiment):
#         return RootModel[Experiment](experiment).model_dump_json(indent=4)


def serialize_experiment(experiment: tuple[ExperimentBase, EchemExperimentBase]) -> str:
    """Given an experiment, determine the type and then pass back the serialized json form"""

    if isinstance(experiment, EchemExperimentBase):
        return RootModel[EchemExperimentBase](experiment).model_dump_json(indent=4)
    if isinstance(experiment, ExperimentBase):
        return RootModel[ExperimentBase](experiment).model_dump_json(indent=4)
    return None


def parse_results(json_string: str) -> ExperimentResult:
    """Parse an experiment result from a json string"""
    return RootModel[ExperimentResult].model_validate_json(json_string).root


def serialize_results(results: ExperimentResult) -> str:
    """Serialize an experiment result to a json string"""
    return RootModel[ExperimentResult](results).model_dump_json(indent=4)


experiment_classes = {
    1: EchemExperimentBase,
    2: CorrectionFactorExperiment,
    # Add more mappings as needed
}


def get_experiment_class_by_id(experiment_id: int):
    """Get the experiment class by the experiment id"""
    return experiment_classes.get(experiment_id, ExperimentBase)


def get_all_type_hints(cls):
    """Get all type hints for a class"""
    hints = {}
    for base in reversed(cls.__mro__):
        hints.update(get_type_hints(base))
    return hints




# region Experiment SQL Functions


def select_next_experiment_id() -> int:
    """Determines the next experiment id by checking the experiment table"""
    result = execute_sql_command(
        """
        SELECT experiment_id FROM experiments
        ORDER BY experiment_id DESC
        LIMIT 1
        """
    )
    if result == []:
        return 10000000
    return result[0][0] + 1


def select_experiment_information(experiment_id: int) -> ExperimentBase:
    """
    Selects the experiment information from the experiments table.

    Args:
        experiment_id (int): The experiment ID.

    Returns:
        ExperimentBase: The experiment information.
    """
    values = execute_sql_command(
        """
        SELECT
            experiment_id,
            project_id,
            project_campaign_id,
            well_type,
            protocol_id,
            pin,
            experiment_type,
            jira_issue_key,
            priority,
            process_type,
            filename
        FROM experiments
        WHERE experiment_id = ?
        """,
        (experiment_id,),
    )

    if values == []:
        return None
    else:

        # With the project_id known to determine the experiment type
        # object type
        project_id = values[0][1]
        experiment_object = experiment_types_by_project_id.get(project_id)()

        experiment = experiment_object
        experiment.experiment_id = experiment_id
        experiment.project_id = values[0][1]
        experiment.project_campaign_id = values[0][2]
        experiment.well_type_number = values[0][3]
        experiment.protocol_id = values[0][4]
        experiment.pin = values[0][5]
        experiment.experiment_type = values[0][6]
        experiment.jira_issue_key = values[0][7]
        experiment.priority = values[0][8]
        experiment.process_type = values[0][9]
        experiment.filename = values[0][10]
        return experiment


def select_experiment_paramaters(
    experiment_to_select: Union[int, EchemExperimentBase]
) -> Union[list, EchemExperimentBase]:
    """
    Selects the experiment parameters from the experiment_parameters table.
    If an experiment_object is provided, the parameters are added to the object.

    Args:
        experiment_to_select (Union[int, EchemExperimentBase]): The experiment ID or object.

    Returns:
        EchemExperimentBase: The experiment parameters.
    """
    if isinstance(experiment_to_select, int):
        experiment_id = experiment_to_select
        experiment_object = None
    else:
        experiment_id = experiment_to_select.experiment_id
        experiment_object = experiment_to_select

    values = execute_sql_command(
        """
        SELECT
            experiment_id,
            parameter_name,
            parameter_value
        FROM experiment_parameters
        WHERE experiment_id = ?
        """,
        (experiment_id,),
    )

    if values == []:
        return None

    if not experiment_object:
        return values

    # With the experiment_id known, look up the project_id to determine the experiment
    # object type
    # project_id_result = execute_sql_command(
    #     "SELECT project_id FROM experiments WHERE experiment_id = ?",
    #     (experiment_id,),
    # )
    # if project_id_result:
    #     project_id = project_id_result[0][0]
    #     experiment_object = experiment_types_by_project_id.get(project_id)()
    # else:
    #     pass

    experiment_object.map_parameter_list_to_experiment(values)
    return experiment_object

def select_specific_parameter(experiment_id: int, parameter_name: str):
    """
    Select a specific parameter from the experiment_parameters table.

    Args:
        experiment_id (int): The experiment ID.
        parameter_name (str): The parameter name.

    Returns:
        any: The parameter value.
    """
    result = execute_sql_command(
        """
        SELECT parameter_value FROM experiment_parameters
        WHERE experiment_id = ?
        AND parameter_name = ?
        """,
        (experiment_id, parameter_name),
    )
    if result == []:
        return None
    return result[0][0]

def select_experiment_status(experiment_id: int) -> str:
    """
    Select the status of an experiment from the well_hx table.

    Args:
        experiment_id (int): The experiment ID.

    Returns:
        str: The status of the experiment.
    """
    result = execute_sql_command(
        """
        SELECT status FROM well_hx
        WHERE experiment_id = ?
        """,
        (experiment_id,),
    )
    if result == []:
        return ValueError("No experiment found with that ID")
    return result[0][0]

def insert_experiment(experiment: ExperimentBase) -> None:
    """
    Insert an experiment into the experiments table.

    Args:
        experiment (ExperimentBase): The experiment to insert.
    """
    insert_experiments([experiment])


def insert_experiments(experiments: List[ExperimentBase]) -> None:
    """
    Insert a list of experiments into the experiments table.

    Args:
        experiments (List[ExperimentBase]): The experiments to insert.
    """
    parameters = []
    for experiment in experiments:
        parameters.append(
            (
                experiment.experiment_id,
                experiment.project_id,
                experiment.project_campaign_id,
                experiment.well_type_number,
                experiment.protocol_id,
                experiment.pin,
                experiment.experiment_type,
                experiment.jira_issue_key,
                experiment.priority,
                experiment.process_type,
                experiment.filename,
                datetime.now().isoformat(timespec="seconds"),
            )
        )
    execute_sql_command_no_return(
        """
        INSERT INTO experiments (
            experiment_id,
            project_id,
            project_campaign_id,
            well_type,
            protocol_id,
            pin,
            experiment_type,
            jira_issue_key,
            priority,
            process_type,
            filename,
            created
            )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT (experiment_id) DO UPDATE SET
            project_id = excluded.project_id,
            project_campaign_id = excluded.project_campaign_id,
            well_type = excluded.well_type,
            protocol_id = excluded.protocol_id,
            pin = excluded.pin,
            experiment_type = excluded.experiment_type,
            jira_issue_key = excluded.jira_issue_key,
            priority = excluded.priority,
            process_type = excluded.process_type,
            filename = excluded.filename,
            created = excluded.created
        """,
        parameters,
    )


def insert_experiment_parameters(experiment: ExperimentBase) -> None:
    """
    Insert the experiment parameters into the experiment_parameters table.

    Args:
        experiment (ExperimentBase): The experiment to insert.
    """
    insert_experiments_parameters([experiment])


def insert_experiments_parameters(experiments: List[ExperimentBase]) -> None:
    """
    Insert the experiment parameters into the experiment_parameters table.

    Args:
        experiments (List[ExperimentBase]): The experiments to insert.
    """
    parameters_to_insert = [] # this will be a list of tuples of the parameters to insert
    for experiment in experiments:
        experiment_parameters: list[ExperimentParameterRecord] = (
            experiment.generate_parameter_list()
        )
        for parameter in experiment_parameters:
            parameters_to_insert.append(
                (
                    experiment.experiment_id,
                    parameter.parameter_type,
                    (
                        json.dumps(parameter.parameter_value, default=decimal_default)
                        if isinstance(parameter.parameter_value, dict)
                        else parameter.parameter_value
                    ),
                    datetime.now().isoformat(timespec="seconds"),
                )
            )
    execute_sql_command_no_return(
        """
        INSERT INTO experiment_parameters (
            experiment_id,
            parameter_name,
            parameter_value,
            created
            )
        VALUES (?, ?, ?, ?)
        """,
        parameters_to_insert,
    )


def update_experiment(experiment: ExperimentBase) -> None:
    """
    Update an experiment in the experiments table.

    Args:
        experiment (ExperimentBase): The experiment to update.
    """
    update_experiments([experiment])


def update_experiments(experiments: List[ExperimentBase]) -> None:
    """
    Update a list of experiments in the experiments table.

    Args:
        experiments (List[ExperimentBase]): The experiments to update.
    """
    parameters = []
    for experiment in experiments:
        parameters.append(
            (
                experiment.project_id,
                experiment.project_campaign_id,
                experiment.well_type_number,
                experiment.protocol_id,
                experiment.pin,
                experiment.experiment_type,
                experiment.jira_issue_key,
                experiment.priority,
                experiment.process_type,
                experiment.filename,
                experiment.experiment_id,
            )
        )
    execute_sql_command_no_return(
        """
        UPDATE experiments
        SET project_id = ?,
            project_campaign_id = ?,
            well_type = ?,
            protocol_id = ?,
            pin = ?,
            experiment_type = ?,
            jira_issue_key = ?,
            priority = ?,
            process_type = ?,
            filename = ?
        WHERE experiment_id = ?
        """,
        parameters,
    )


def update_experiment_status(
    experiment: Union[ExperimentBase, int],
    status: ExperimentStatus = None,
    status_date: datetime = None,
) -> None:
    """
    Update the status of an experiment in the experiments table.

    When provided with an int, the experiment_id is the int, and the status and
    status_date are the other two arguments.
    If no status is provided, the function will not make assumptions and will do nothing.

    When provided with an ExperimentBase object, the object's attributes will be
    used to update the status.
    If an object is provided along with a status and status date, the object's
    attributes will be updated with the status and status date.

    Args:
        experiment_id (int): The experiment ID.
        status (ExperimentStatus): The status to update to.
    """
    # Handel the case where the experiment is passed as an object or an int
    # If it is an int, then the experiment_id is the int, and the status and the
    # status_date are the other two arguments
    # If it is an object, then use the experimentbase object for the data
    if isinstance(experiment, int):
        experiment_id = experiment
        if status is None:
            return
        if status_date is None:
            status_date = datetime.now().isoformat(timespec="seconds")

        experiment_info = select_experiment_information(experiment_id)
        project_id = experiment_info.project_id
        well_id = experiment_info.well_id

    else:
        experiment_id = experiment.experiment_id
        if status is not None:
            experiment.set_status(status)
        else:
            status = experiment.status
        if status_date is not None:
            experiment.status_date = status_date
        else:
            status_date = experiment.status_date
        project_id = experiment.project_id
        well_id = experiment.well_id

    execute_sql_command(
        """
        UPDATE well_hx
        SET status = ?,
            status_date = ?,
            experiment_id = ?,
            project_id = ?
        WHERE well_id = ?
        AND plate_id = (SELECT id FROM wellplates WHERE current = 1)
        """,
        (
            status.value,
            status_date,
            experiment_id,
            project_id,
            well_id,
        ),
    )


def update_experiments_statuses(
    experiments: List[ExperimentBase],
    exp_status: ExperimentStatus,
    status_date: datetime = None,
) -> None:
    """
    Set the status of a list of experiments in the well_hx table.

    Args:
        experiments (List[ExperimentBase]): The experiments to set the status for.
        status (ExperimentStatus): The status to set for the experiments.
        status_date (datetime): The status date to set for the experiments.
    """
    if status_date is None:
        status_date = datetime.now().isoformat(timespec="seconds")

    for experiment in experiments:
        experiment.set_status(exp_status)

    parameters = [
        (
            exp_status.value,
            status_date,
            experiment.experiment_id,
            experiment.project_id,
            experiment.well_id,
        )
        for experiment in experiments
    ]
    execute_sql_command_no_return(
        """
        UPDATE well_hx
        SET status = ?,
        status_date = ?,
        experiment_id = ?,
        project_id = ?
        WHERE well_id = ?
        AND plate_id = (SELECT id FROM wellplates WHERE current = 1)
        """,
        parameters,
    )


# endregion

# region Result Functions

def insert_experiment_result(entry: ExperimentResultsRecord) -> None:
    """
    Insert an entry into the result table.

    Args:
        entry (ResultTableEntry): The entry to insert.
    """
    command = """
        INSERT INTO experiment_results (
            experiment_id,
            result_type,
            result_value,
            context
            )
        VALUES (?, ?, ?, ?)
        """
    if isinstance(entry.result_value, dict):
        entry.result_value = json.dumps(entry.result_value)
    if isinstance(entry.result_value, Path):
        entry.result_value = str(entry.result_value)
    parameters = (entry.experiment_id, entry.result_type, entry.result_value, entry.context)
    execute_sql_command_no_return(command, parameters)

def insert_experiment_results(entries: List[ExperimentResultsRecord]) -> None:
    """
    Insert a list of entries into the result table.

    Args:
        entries (List[ResultTableEntry]): The entries to insert.
    """
    for entry in entries:
        insert_experiment_result(entry)


def select_results(experiment_id: int) -> List[ExperimentResultsRecord]:
    """
    Select the entries from the result table that are associated with an experiment.

    Args:
        experiment_id (int): The experiment ID.

    Returns:
        List[ResultTableEntry]: The entries from the result table.
    """
    result_parameters = execute_sql_command(
        """
        SELECT
            experiment_id,
            result_type,
            result_value,
            context
        FROM experiment_results
        WHERE experiment_id = ?
        """,
        (experiment_id,),
    )
    results = []
    for row in result_parameters:
        results.append(ExperimentResultsRecord(*row))
    return results


def select_specific_result(
    experiment_id: int, result_type: str, context: str = None
) -> Union[List[ExperimentResultsRecord], ExperimentResultsRecord]:
    """
    Select a specific entry from the result table that is associated with an experiment.

    Args:
        experiment_id (int): The experiment ID.
        result_type (str): The result type.

    Returns:
        ResultTableEntry: The entry from the result table.
    """
    if context is None:
        result = execute_sql_command(
            """
            SELECT 
                experiment_id,
                result_type,
                result_value,
                context
            FROM experiment_results
            WHERE experiment_id = ? AND result_type = ?
            """,
            (experiment_id, result_type),
        )
    else:
        result = execute_sql_command(
            """
            SELECT 
                experiment_id,
                result_type,
                result_value,
                context
            FROM experiment_results
            WHERE experiment_id = ? AND result_type = ? AND context = ?
            """,
            (experiment_id, result_type, context),
        )
    if result == []:
        return None
    
    results = []
    for row in result:
        results.append(ExperimentResultsRecord(*row))
    
    if len(results) == 1:
        return results[0]

    return results


# endregion

def decimal_default(obj):
    if isinstance(obj, Decimal):
        return float(obj)
    raise TypeError
